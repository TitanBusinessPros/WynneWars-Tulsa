<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Wars</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            padding: 20px;
            margin: 0;
            min-height: 100vh;
        }
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 800px;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #667eea;
            margin-top: 0;
        }
        .game-setup {
            text-align: center;
            margin-bottom: 20px;
        }
        .game-setup button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
        }
        .game-setup button:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
        .board {
            display: grid;
            grid-template-columns: repeat(6, 70px);
            gap: 8px;
            margin: 20px auto;
            justify-content: center;
            position: relative;
        }
        .cell {
            width: 70px;
            height: 70px;
            border: 3px solid #ddd;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
            position: relative;
        }
        .cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .cell.player1 {
            border-color: #5568d3;
        }
        .cell.player2 {
            border-color: #f5576c;
        }
        .cell.bonus {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-color: #f59e0b;
            color: white;
        }
        .cell.selected {
            border: 3px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }
        .cell.valid-move {
            border-color: #4ade80;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.4);
        }
        .cell.valid-expansion {
            border-color: #60a5fa;
            box-shadow: 0 0 10px rgba(96, 165, 250, 0.4);
        }
        .cell.valid-fortify {
            border-color: #a78bfa;
            box-shadow: 0 0 10px rgba(167, 139, 250, 0.4);
        }
        .army-count {
            font-size: 28px;
            font-weight: bold;
            color: white;
        }
        .resource {
            font-size: 11px;
            opacity: 0.9;
        }
        .bonus-icon {
            font-size: 20px;
        }
        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #667eea;
            font-weight: 500;
        }
        .player-info {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            gap: 10px;
        }
        .player-card {
            flex: 1;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        .player-card.player1 {
            background: linear-gradient(135deg, #667eea, #5568d3);
            color: white;
        }
        .player-card.player2 {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
        }
        .player-card.active {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            border: 3px solid #ffd700;
        }
        .actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .actions button {
            background: #10b981;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .actions button:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-2px);
        }
        .actions button:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal.show {
            display: flex;
        }
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        .modal-content h2 {
            color: #667eea;
            margin-top: 0;
        }
        .army-slider-container {
            margin: 20px 0;
        }
        .army-slider {
            width: 100%;
            margin: 10px 0;
        }
        .slider-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .modal-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .modal-buttons .confirm {
            background: #10b981;
            color: white;
        }
        .modal-buttons .confirm:hover {
            background: #059669;
        }
        .modal-buttons .cancel {
            background: #ef4444;
            color: white;
        }
        .modal-buttons .cancel:hover {
            background: #dc2626;
        }
        .rules {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.6;
        }
        .rules h3 {
            color: #667eea;
            margin-top: 0;
        }
        .rules ul {
            padding-left: 20px;
        }
        .rules li {
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚öîÔ∏è Territory Wars ‚öîÔ∏è</h1>
        
        <div style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: white; padding: 12px; border-radius: 10px; text-align: center; font-weight: bold; margin-bottom: 15px; box-shadow: 0 4px 10px rgba(251, 191, 36, 0.3);">
            ‚≠ê 3 HIDDEN BONUS SQUARES (+5 armies each) ‚≠ê
        </div>

        <div style="background: #334155; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
            <div style="color: white; font-weight: bold; margin-bottom: 10px; font-size: 18px;">SELECT LEVEL</div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="level-btn" id="level1-btn" style="background: #667eea; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s;">
                    LEVEL 1
                </button>
                <button class="level-btn" id="level2-btn" style="background: #f59e0b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s;">
                    LEVEL 2 üï≥Ô∏è
                </button>
            </div>
        </div>
        
        <div class="game-setup">
            <button id="pvp-btn">2 Players</button>
            <button id="ai-btn">Play vs AI</button>
            <button id="reset-btn">New Game</button>
        </div>

        <div class="player-info">
            <div class="player-card player1" id="p1-card">
                <div style="font-size: 20px; font-weight: bold;">Player 1</div>
                <div>Territories: <span id="p1-territories">2</span></div>
                <div>Total Armies: <span id="p1-armies">6</span></div>
            </div>
            <div class="player-card player2" id="p2-card">
                <div style="font-size: 20px; font-weight: bold;">Player 2 <span id="ai-label"></span></div>
                <div>Territories: <span id="p2-territories">2</span></div>
                <div>Total Armies: <span id="p2-armies">6</span></div>
            </div>
        </div>

        <div class="status" id="status">Select game mode to start</div>

        <div style="background: #e0e7ff; padding: 10px; border-radius: 8px; text-align: center; margin: 10px 0; font-weight: bold; color: #4338ca;" id="phase-indicator">
            Current Phase: --
        </div>

        <div class="actions">
            <button id="end-btn">Next Phase</button>
        </div>

        <div class="board" id="board"></div>

        <div class="rules">
            <h3>üìú How to Play</h3>
            <ul>
                <li><strong>Goal:</strong> Capture all territories or eliminate all enemy armies!</li>
                <li><strong>Setup:</strong> Each player starts with 2 swordsmen groups and 1 wizard. <strong>3 hidden bonus squares hold 5 armies each!</strong></li>
                <li><strong>Units:</strong>
                    <ul>
                        <li><strong>Swordsmen:</strong> Attack adjacent enemies. Higher number wins! (7 vs 5 = 2 remaining)</li>
                        <li><strong>Wizard üîÆ:</strong> Always 1 unit. Moves 2 squares per turn. Can attack up to 2 squares away in straight lines. <strong>Kills 2 units per attack!</strong></li>
                    </ul>
                </li>
                <li><strong>Your Turn (5 Phases):</strong>
                    <ul>
                        <li><strong>üîÆ Wizard Movement:</strong> Move your wizard up to 2 squares (one square at a time to adjacent empty spaces)</li>
                        <li><strong>1Ô∏è‚É£ Deploy Phase:</strong> Place armies on swordsmen OR expand to adjacent empty squares</li>
                        <li><strong>2Ô∏è‚É£ Expand Phase:</strong> Claim adjacent empty squares with swordsmen</li>
                        <li><strong>3Ô∏è‚É£ Attack Phase:</strong> Attack enemies! Wizards shoot magic balls! üîÆ‚ö°</li>
                        <li><strong>4Ô∏è‚É£ Fortify Phase:</strong> Move swordsmen between adjacent territories</li>
                        <li><strong>Bonus Discovery:</strong> Find hidden bonus squares - you'll get fireworks and +5 armies! üéÜ</li>
                        <li>Click "Next Phase" to skip optional phases, "End Turn" to finish</li>
                    </ul>
                </li>
                <li><strong>Strategy:</strong> Move your wizard to strategic positions! Use it to snipe enemies from 2 squares away. Protect it - it's fragile!</li>
            </ul>
        </div>
    </div>

    <!-- Army Movement Modal -->
    <div id="move-modal" class="modal">
        <div class="modal-content">
            <h2>Move Armies</h2>
            <p id="move-description">How many armies to move?</p>
            <div class="army-slider-container">
                <div class="slider-value" id="slider-value">1</div>
                <input type="range" id="army-slider" class="army-slider" min="1" max="10" value="1">
                <div style="font-size: 12px; color: #666; margin-top: 10px;">
                    <span>Leaving: <strong id="leaving-armies">0</strong></span> | 
                    <span>Moving: <strong id="moving-armies">1</strong></span>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="confirm" id="confirm-move">Move</button>
                <button class="cancel" id="cancel-move">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const BOARD_SIZE = 36;
        const game = {
            board: [],
            currentPlayer: 1,
            gameMode: null,
            selectedCell: null,
            phase: 'setup',
            armiesToDeploy: 0,
            turnCount: 0,
            maxTurns: 20,
            gameOver: false,
            pendingMove: null,
            wizardMovesRemaining: 0,
            currentLevel: 1,
            trapDoor: null
        };

        function init() {
            game.board = Array(BOARD_SIZE).fill(null).map(() => ({
                owner: 0,
                armies: 0,
                isBonus: false,
                isWizard: false,
                isTrapDoor: false
            }));
            
            // Starting positions for swordsmen
            game.board[5] = { owner: 1, armies: 3, isBonus: false, isWizard: false, isTrapDoor: false };
            game.board[14] = { owner: 1, armies: 3, isBonus: false, isWizard: false, isTrapDoor: false };
            game.board[21] = { owner: 2, armies: 3, isBonus: false, isWizard: false, isTrapDoor: false };
            game.board[30] = { owner: 2, armies: 3, isBonus: false, isWizard: false, isTrapDoor: false };
            
            // Wizard positions - one per player, isolated
            game.board[2] = { owner: 1, armies: 1, isBonus: false, isWizard: true, isTrapDoor: false };
            game.board[33] = { owner: 2, armies: 1, isBonus: false, isWizard: true, isTrapDoor: false };
            
            // Bonus squares with 5 armies
            const bonusPositions = [10, 17, 25];
            bonusPositions.forEach(pos => {
                game.board[pos] = { owner: 0, armies: 5, isBonus: true, isWizard: false, isTrapDoor: false };
            });
            
            // Level 2: Add hidden trap door
            if (game.currentLevel === 2) {
                const trapPosition = 18; // Hidden trap in middle area
                game.board[trapPosition].isTrapDoor = true;
                game.trapDoor = trapPosition;
            }
            
            game.currentPlayer = 1;
            game.turnCount = 0;
            game.phase = 'setup';
            game.selectedCell = null;
            game.gameOver = false;
            game.pendingMove = null;
            
            renderBoard();
            updateUI();
            
            document.getElementById('pvp-btn').onclick = () => startGame('pvp');
            document.getElementById('ai-btn').onclick = () => startGame('ai');
            document.getElementById('reset-btn').onclick = resetGame;
            document.getElementById('end-btn').onclick = endTurn;
            document.getElementById('level1-btn').onclick = () => selectLevel(1);
            document.getElementById('level2-btn').onclick = () => selectLevel(2);
            
            // Modal controls
            document.getElementById('army-slider').oninput = updateSliderDisplay;
            document.getElementById('confirm-move').onclick = confirmMove;
            document.getElementById('cancel-move').onclick = cancelMove;
        }

        function startGame(mode) {
            game.gameMode = mode;
            game.phase = 'wizard_move';
            game.wizardMovesRemaining = 2;
            game.armiesToDeploy = getReinforcementCount(game.currentPlayer);
            game.gameOver = false;
            document.getElementById('ai-label').textContent = mode === 'ai' ? '(AI)' : '';
            updateUI();
            renderBoard();
        }

        function selectLevel(level) {
            game.currentLevel = level;
            
            // Update button styles
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            });
            
            const selectedBtn = document.getElementById(`level${level}-btn`);
            selectedBtn.style.transform = 'scale(1.1)';
            selectedBtn.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.6)';
            
            // Reset the game with new level
            init();
            
            showStatus(`Level ${level} selected! ${level === 2 ? 'üï≥Ô∏è Beware of the hidden trap door!' : ''} Choose game mode to start.`);
        }

        function resetGame() {
            init();
            document.getElementById('status').textContent = 'Select game mode to start';
            document.getElementById('ai-label').textContent = '';
            hideModal();
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            game.board.forEach((cell, i) => {
                const cellEl = document.createElement('div');
                cellEl.className = 'cell';
                
                if (cell.owner === 1) cellEl.classList.add('player1');
                if (cell.owner === 2) cellEl.classList.add('player2');
                if (game.selectedCell === i) cellEl.classList.add('selected');
                
                if (cell.owner > 0) {
                    const playerColor = cell.owner === 1 ? 'rgba(102, 126, 234, 0.6)' : 'rgba(240, 147, 251, 0.6)';
                    const characterImage = cell.isWizard 
                        ? 'https://github.com/TitanBusinessPros/Wynne-Wars/raw/main/Wizard.png'
                        : 'https://github.com/TitanBusinessPros/Wynne-Wars/raw/main/Swordsmen.png';
                    
                    cellEl.innerHTML = `
                        <div style="position: relative; width: 100%; height: 100%;">
                            <img src="${characterImage}" 
                                 style="width: 100%; height: 100%; object-fit: contain; position: absolute; top: 0; left: 0;">
                            <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: ${playerColor}; mix-blend-mode: multiply;"></div>
                            <div class="army-count" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; text-shadow: 2px 2px 4px rgba(0,0,0,0.8), -1px -1px 2px rgba(255,255,255,0.5);">${cell.armies}</div>
                        </div>
                    `;
                }
                
                cellEl.onclick = () => handleCellClick(i);
                boardEl.appendChild(cellEl);
            });
            
            // Highlight valid targets
            if (game.selectedCell !== null) {
                if (game.phase === 'wizard_move') {
                    highlightWizardMovement(game.selectedCell);
                } else if (game.phase === 'expand') {
                    highlightValidExpansion(game.selectedCell);
                } else if (game.phase === 'attack') {
                    const isWizard = game.board[game.selectedCell].isWizard;
                    if (isWizard) {
                        highlightWizardTargets(game.selectedCell);
                    } else {
                        highlightValidTargets(game.selectedCell);
                    }
                } else if (game.phase === 'fortify') {
                    highlightValidFortify(game.selectedCell);
                }
            }
        }

        function handleCellClick(i) {
            if (!game.gameMode || game.gameOver) return;
            if (game.gameMode === 'ai' && game.currentPlayer === 2) return;
            
            const cell = game.board[i];
            
            if (game.phase === 'wizard_move') {
                if (game.selectedCell === null) {
                    // Select wizard to move
                    if (cell.owner === game.currentPlayer && cell.isWizard) {
                        game.selectedCell = i;
                        renderBoard();
                        showStatus(`Player ${game.currentPlayer}: Move wizard to adjacent square (${game.wizardMovesRemaining} moves left)`);
                    } else {
                        showStatus(`Select your wizard to move it!`);
                    }
                } else {
                    // Moving wizard
                    if (i === game.selectedCell) {
                        game.selectedCell = null;
                        renderBoard();
                        updateUI();
                    } else if (isAdjacent(game.selectedCell, i) && cell.owner === 0) {
                        // Valid wizard movement to empty square
                        game.board[i].owner = game.currentPlayer;
                        game.board[i].armies = 1;
                        game.board[i].isWizard = true;
                        game.board[game.selectedCell].owner = 0;
                        game.board[game.selectedCell].armies = 0;
                        game.board[game.selectedCell].isWizard = false;
                        
                        game.wizardMovesRemaining--;
                        game.selectedCell = null;
                        
                        // Check for trap door
                        if (game.board[i].isTrapDoor) {
                            setTimeout(() => {
                                playTrapDoorSound();
                                showStatus(`üíÄ TRAP DOOR! Player ${game.currentPlayer}'s wizard fell into the trap!`);
                                game.board[i].owner = 0;
                                game.board[i].armies = 0;
                                game.board[i].isWizard = false;
                                renderBoard();
                                updateUI();
                            }, 100);
                        }
                        
                        if (game.wizardMovesRemaining === 0) {
                            game.phase = 'deploy';
                        }
                        
                        renderBoard();
                        updateUI();
                    } else if (isAdjacent(game.selectedCell, i) && cell.owner !== 0) {
                        showStatus(`Can only move wizard to empty squares!`);
                    } else {
                        showStatus(`Wizard can only move to adjacent squares!`);
                    }
                }
            } else if (game.phase === 'deploy') {
                if (game.armiesToDeploy > 0) {
                    // Can deploy to owned territories OR adjacent empty squares
                    if (cell.owner === game.currentPlayer) {
                        // Don't allow deploying to wizard squares
                        if (game.board[i].isWizard) {
                            showStatus(`Can't deploy to wizard! Wizards remain at 1 army.`);
                        } else {
                            game.board[i].armies++;
                            game.armiesToDeploy--;
                            
                            if (game.armiesToDeploy === 0) {
                                game.phase = 'expand';
                            }
                            
                            renderBoard();
                            updateUI();
                        }
                    } else if (cell.owner === 0 && isAdjacentToPlayer(i, game.currentPlayer)) {
                        // Deploying to adjacent empty square
                        const bonusArmies = game.board[i].isBonus ? game.board[i].armies : 0;
                        const isTrap = game.board[i].isTrapDoor;
                        
                        game.board[i].owner = game.currentPlayer;
                        game.board[i].armies = 1 + bonusArmies;
                        game.board[i].isBonus = false;
                        game.armiesToDeploy--;
                        
                        if (isTrap) {
                            setTimeout(() => {
                                playTrapDoorSound();
                                showStatus(`üíÄ TRAP DOOR! Player ${game.currentPlayer} lost their army!`);
                                game.board[i].owner = 0;
                                game.board[i].armies = 0;
                                renderBoard();
                                updateUI();
                            }, 100);
                        } else if (bonusArmies > 0) {
                            showStatus(`Player ${game.currentPlayer} found BONUS! +${bonusArmies} armies! ‚≠êüéÜ`);
                            celebrateBonus();
                        }
                        
                        if (game.armiesToDeploy === 0) {
                            game.phase = 'expand';
                        }
                        
                        renderBoard();
                        updateUI();
                    } else {
                        showStatus(`Deploy to your territories or adjacent empty squares! (${game.armiesToDeploy} armies left)`);
                    }
                }
            } else if (game.phase === 'expand') {
                if (game.selectedCell === null) {
                    // Select source territory
                    if (cell.owner === game.currentPlayer && cell.armies > 1) {
                        game.selectedCell = i;
                        renderBoard();
                        showStatus(`Player ${game.currentPlayer}: Click an adjacent empty square to expand`);
                    } else if (cell.owner === game.currentPlayer && cell.armies <= 1) {
                        showStatus(`Need at least 2 armies to expand!`);
                    }
                } else {
                    // Choosing target
                    if (i === game.selectedCell) {
                        game.selectedCell = null;
                        renderBoard();
                        updateUI();
                    } else if (isAdjacent(game.selectedCell, i) && cell.owner === 0) {
                        // Valid expansion - show modal
                        showMoveModal(game.selectedCell, i, 'expand');
                    } else if (isAdjacent(game.selectedCell, i) && cell.owner !== 0) {
                        showStatus(`Can't expand there! Click an empty square.`);
                    } else {
                        showStatus(`Not adjacent!`);
                    }
                }
            } else if (game.phase === 'attack') {
                if (game.selectedCell === null) {
                    if (cell.owner === game.currentPlayer) {
                        game.selectedCell = i;
                        renderBoard();
                        const isWizard = game.board[i].isWizard;
                        if (isWizard) {
                            showStatus(`Player ${game.currentPlayer}: Wizard selected! Click enemy up to 2 squares away (cardinal directions)`);
                        } else {
                            showStatus(`Player ${game.currentPlayer}: Click an adjacent enemy to attack`);
                        }
                    }
                } else {
                    if (i === game.selectedCell) {
                        game.selectedCell = null;
                        renderBoard();
                        updateUI();
                    } else {
                        const sourceCell = game.board[game.selectedCell];
                        const isWizard = sourceCell.isWizard;
                        
                        if (isWizard) {
                            // Wizard can attack up to 2 squares away in cardinal directions
                            if (isWithinWizardRange(game.selectedCell, i)) {
                                if (cell.owner !== game.currentPlayer && cell.owner !== 0) {
                                    performWizardAttack(game.selectedCell, i);
                                    game.selectedCell = null;
                                    renderBoard();
                                    updateUI();
                                    
                                    if (!game.gameOver) {
                                        checkWinCondition();
                                    }
                                } else {
                                    showStatus(`Click an enemy territory to attack!`);
                                }
                            } else {
                                showStatus(`Wizard can only attack up to 2 squares away in straight lines!`);
                            }
                        } else {
                            // Regular swordsman attack
                            if (isAdjacent(game.selectedCell, i)) {
                                if (cell.owner !== game.currentPlayer && cell.owner !== 0) {
                                    performAttack(game.selectedCell, i);
                                    game.selectedCell = null;
                                    renderBoard();
                                    updateUI();
                                    
                                    if (!game.gameOver) {
                                        checkWinCondition();
                                    }
                                } else {
                                    showStatus(`Click an enemy territory to attack!`);
                                }
                            } else {
                                showStatus(`Not adjacent!`);
                            }
                        }
                    }
                }
            } else if (game.phase === 'fortify') {
                if (game.selectedCell === null) {
                    // Select source territory
                    if (cell.owner === game.currentPlayer && cell.armies > 1) {
                        game.selectedCell = i;
                        renderBoard();
                        showStatus(`Player ${game.currentPlayer}: Click an adjacent friendly territory to move armies`);
                    } else if (cell.owner === game.currentPlayer && cell.armies <= 1) {
                        showStatus(`Need at least 2 armies to move troops!`);
                    }
                } else {
                    // Choosing target
                    if (i === game.selectedCell) {
                        game.selectedCell = null;
                        renderBoard();
                        updateUI();
                    } else if (isAdjacent(game.selectedCell, i) && cell.owner === game.currentPlayer) {
                        // Valid fortify move - show modal
                        showMoveModal(game.selectedCell, i, 'fortify');
                    } else if (isAdjacent(game.selectedCell, i)) {
                        showStatus(`Can only move to your own territories!`);
                    } else {
                        showStatus(`Not adjacent!`);
                    }
                }
            }
        }

        function showMoveModal(from, to, action) {
            const fromCell = game.board[from];
            const maxMove = fromCell.armies - 1;
            
            game.pendingMove = { from, to, action };
            
            const slider = document.getElementById('army-slider');
            slider.max = maxMove;
            slider.value = Math.min(maxMove, slider.value);
            
            if (action === 'expand') {
                const toCell = game.board[to];
                const bonusText = toCell.isBonus ? ` (Bonus: +${toCell.armies} armies!)` : '';
                document.getElementById('move-description').textContent = 
                    `Expanding to new territory${bonusText}`;
            } else if (action === 'fortify') {
                document.getElementById('move-description').textContent = 
                    `Moving armies to friendly territory`;
            }
            
            updateSliderDisplay();
            document.getElementById('move-modal').classList.add('show');
        }

        function hideModal() {
            document.getElementById('move-modal').classList.remove('show');
            game.pendingMove = null;
        }

        function updateSliderDisplay() {
            const slider = document.getElementById('army-slider');
            const moving = parseInt(slider.value);
            const fromCell = game.board[game.pendingMove.from];
            const leaving = fromCell.armies - moving;
            
            document.getElementById('slider-value').textContent = moving;
            document.getElementById('moving-armies').textContent = moving;
            document.getElementById('leaving-armies').textContent = leaving;
        }

        function confirmMove() {
            if (!game.pendingMove) return;
            
            const { from, to, action } = game.pendingMove;
            const armiesToMove = parseInt(document.getElementById('army-slider').value);
            
            if (action === 'expand') {
                performExpansion(from, to, armiesToMove);
            } else if (action === 'fortify') {
                performFortify(from, to, armiesToMove);
            }
            
            hideModal();
            game.selectedCell = null;
            renderBoard();
            updateUI();
            
            if (!game.gameOver) {
                checkWinCondition();
            }
        }

        function cancelMove() {
            hideModal();
        }

        function performExpansion(from, to, armiesToMove) {
            const targetCell = game.board[to];
            const bonusArmies = targetCell.isBonus ? targetCell.armies : 0;
            
            game.board[from].armies -= armiesToMove;
            game.board[to].owner = game.currentPlayer;
            game.board[to].armies = armiesToMove + bonusArmies;
            game.board[to].isBonus = false;
            
            // Check for trap door
            if (targetCell.isTrapDoor) {
                setTimeout(() => {
                    playTrapDoorSound();
                    showStatus(`üíÄ TRAP DOOR! Player ${game.currentPlayer} lost ${game.board[to].armies} armies!`);
                    game.board[to].owner = 0;
                    game.board[to].armies = 0;
                    renderBoard();
                    updateUI();
                }, 100);
            } else if (bonusArmies > 0) {
                showStatus(`Player ${game.currentPlayer} found BONUS! +${bonusArmies} armies! ‚≠êüéÜ`);
                celebrateBonus();
            } else {
                showStatus(`Player ${game.currentPlayer} expanded territory!`);
            }
        }

        function celebrateBonus() {
            // Play celebration sound
            playBonusSound();
            
            // Create fireworks effect
            createFireworks();
        }

        function playBonusSound() {
            // Create a celebratory sound using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Play multiple notes in quick succession for a fanfare
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = freq;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                }, i * 100);
            });
        }

        function createFireworks() {
            const container = document.querySelector('.container');
            const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
            
            // Create multiple firework bursts
            for (let burst = 0; burst < 3; burst++) {
                setTimeout(() => {
                    const centerX = container.offsetWidth / 2;
                    const centerY = 100 + Math.random() * 100;
                    
                    // Create particles
                    for (let i = 0; i < 30; i++) {
                        const particle = document.createElement('div');
                        particle.style.position = 'absolute';
                        particle.style.left = centerX + 'px';
                        particle.style.top = centerY + 'px';
                        particle.style.width = '8px';
                        particle.style.height = '8px';
                        particle.style.borderRadius = '50%';
                        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                        particle.style.pointerEvents = 'none';
                        particle.style.zIndex = '1000';
                        
                        container.style.position = 'relative';
                        container.appendChild(particle);
                        
                        // Random direction
                        const angle = (Math.PI * 2 * i) / 30;
                        const velocity = 100 + Math.random() * 100;
                        const vx = Math.cos(angle) * velocity;
                        const vy = Math.sin(angle) * velocity;
                        
                        // Animate
                        let posX = centerX;
                        let posY = centerY;
                        let life = 1;
                        
                        const animate = () => {
                            posX += vx * 0.016;
                            posY += vy * 0.016;
                            life -= 0.02;
                            
                            particle.style.left = posX + 'px';
                            particle.style.top = posY + 'px';
                            particle.style.opacity = life;
                            
                            if (life > 0) {
                                requestAnimationFrame(animate);
                            } else {
                                particle.remove();
                            }
                        };
                        
                        requestAnimationFrame(animate);
                    }
                }, burst * 300);
            }
        }

        function performFortify(from, to, armiesToMove) {
            game.board[from].armies -= armiesToMove;
            game.board[to].armies += armiesToMove;
            
            showStatus(`Player ${game.currentPlayer} moved ${armiesToMove} armies`);
        }

        function isAdjacent(i, j) {
            const row1 = Math.floor(i / 6);
            const col1 = i % 6;
            const row2 = Math.floor(j / 6);
            const col2 = j % 6;
            
            return (Math.abs(row1 - row2) === 1 && col1 === col2) ||
                   (Math.abs(col1 - col2) === 1 && row1 === row2);
        }

        function isAdjacentToPlayer(i, player) {
            const adjacentCells = getAdjacentCells(i);
            return adjacentCells.some(adj => game.board[adj].owner === player);
        }

        function isWithinWizardRange(from, to) {
            const rowFrom = Math.floor(from / 6);
            const colFrom = from % 6;
            const rowTo = Math.floor(to / 6);
            const colTo = to % 6;
            
            // Must be in same row or column (cardinal directions only)
            if (rowFrom !== rowTo && colFrom !== colTo) return false;
            
            // Calculate distance
            const distance = Math.abs(rowFrom - rowTo) + Math.abs(colFrom - colTo);
            
            // Must be 1 or 2 squares away
            return distance >= 1 && distance <= 2;
        }

        function highlightValidExpansion(i) {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cellEl, j) => {
                if (isAdjacent(i, j) && game.board[j].owner === 0) {
                    cellEl.classList.add('valid-expansion');
                }
            });
        }

        function highlightValidFortify(i) {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cellEl, j) => {
                if (isAdjacent(i, j) && game.board[j].owner === game.currentPlayer) {
                    cellEl.classList.add('valid-fortify');
                }
            });
        }

        function highlightWizardTargets(i) {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cellEl, j) => {
                if (isWithinWizardRange(i, j) && game.board[j].owner !== game.currentPlayer && game.board[j].owner !== 0) {
                    cellEl.classList.add('valid-move');
                }
            });
        }

        function highlightWizardMovement(i) {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cellEl, j) => {
                if (isAdjacent(i, j) && game.board[j].owner === 0) {
                    cellEl.classList.add('valid-expansion');
                }
            });
        }

        function highlightValidTargets(i) {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cellEl, j) => {
                if (isAdjacent(i, j) && game.board[j].owner !== game.currentPlayer && game.board[j].owner !== 0) {
                    cellEl.classList.add('valid-move');
                }
            });
        }

        function performAttack(from, to) {
            const attacker = game.board[from];
            const defender = game.board[to];
            
            // Simple number comparison - higher number wins
            if (attacker.armies > defender.armies) {
                // Attacker wins - remaining armies = attacker - defender
                const remainingArmies = attacker.armies - defender.armies;
                game.board[to].owner = game.currentPlayer;
                game.board[to].armies = remainingArmies;
                game.board[from].armies = 0;
                game.board[from].owner = 0; // Territory becomes empty
                
                showStatus(`Player ${game.currentPlayer} conquered! ${attacker.armies} vs ${defender.armies} = ${remainingArmies} remaining üéØ`);
            } else {
                // Defender wins or tie - attacker's territory becomes empty
                game.board[from].armies = 0;
                game.board[from].owner = 0;
                showStatus(`Attack failed! ${attacker.armies} vs ${defender.armies} - Defender holds! üõ°Ô∏è`);
            }
        }

        function performWizardAttack(from, to) {
            // Play wizard sound and animate magic ball
            playWizardSound();
            
            // Determine ball color based on current player
            const ballColor = game.currentPlayer === 1 ? 'blue' : 'red';
            
            animateMagicBall(from, to, ballColor, () => {
                // After animation completes, resolve the attack
                const defender = game.board[to];
                
                // Wizard kills 2 units
                const remainingDefenders = defender.armies - 2;
                
                if (remainingDefenders <= 0) {
                    // Target destroyed - square becomes empty
                    game.board[to].owner = 0;
                    game.board[to].armies = 0;
                    game.board[to].isWizard = false;
                    
                    showStatus(`Player ${game.currentPlayer}'s Wizard destroyed target! üîÆ‚ö°`);
                } else {
                    // Target survives with reduced armies
                    game.board[to].armies = remainingDefenders;
                    
                    showStatus(`Player ${game.currentPlayer}'s Wizard killed 2 units! ${remainingDefenders} remain! üîÆ‚ö°`);
                }
                
                renderBoard();
                updateUI();
                
                if (!game.gameOver) {
                    checkWinCondition();
                }
            });
        }

        function playWizardSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create mystical whoosh sound
            const oscillator1 = audioContext.createOscillator();
            const oscillator2 = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator1.connect(gainNode);
            oscillator2.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Descending frequency for magic effect
            oscillator1.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator1.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.5);
            oscillator1.type = 'sine';
            
            oscillator2.frequency.setValueAtTime(1200, audioContext.currentTime);
            oscillator2.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.5);
            oscillator2.type = 'triangle';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator1.start(audioContext.currentTime);
            oscillator2.start(audioContext.currentTime);
            oscillator1.stop(audioContext.currentTime + 0.5);
            oscillator2.stop(audioContext.currentTime + 0.5);
        }

        function playTrapDoorSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create ominous descending trap door sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Sharp descending "falling" sound
            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.8);
            oscillator.type = 'sawtooth';
            
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.8);
            
            // Add a "thud" at the end
            setTimeout(() => {
                const thud = audioContext.createOscillator();
                const thudGain = audioContext.createGain();
                
                thud.connect(thudGain);
                thudGain.connect(audioContext.destination);
                
                thud.frequency.setValueAtTime(80, audioContext.currentTime);
                thud.type = 'sine';
                
                thudGain.gain.setValueAtTime(0.5, audioContext.currentTime);
                thudGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                thud.start(audioContext.currentTime);
                thud.stop(audioContext.currentTime + 0.2);
            }, 600);
        }

        function animateMagicBall(from, to, color, onComplete) {
            const board = document.getElementById('board');
            const cells = board.querySelectorAll('.cell');
            
            const fromCell = cells[from];
            const toCell = cells[to];
            
            if (!fromCell || !toCell) {
                onComplete();
                return;
            }
            
            const fromRect = fromCell.getBoundingClientRect();
            const toRect = toCell.getBoundingClientRect();
            
            // Color definitions
            const colors = {
                blue: {
                    gradient: 'radial-gradient(circle, #60a5fa, #3b82f6, #1e40af)',
                    glow: '#60a5fa'
                },
                red: {
                    gradient: 'radial-gradient(circle, #f87171, #ef4444, #dc2626)',
                    glow: '#f87171'
                }
            };
            
            const selectedColor = colors[color];
            
            // Create magic ball on body with FIXED positioning
            const ball = document.createElement('div');
            ball.style.position = 'fixed';
            ball.style.width = '50px';
            ball.style.height = '50px';
            ball.style.borderRadius = '50%';
            ball.style.background = selectedColor.gradient;
            ball.style.boxShadow = `0 0 40px ${selectedColor.glow}, 0 0 80px ${selectedColor.glow}`;
            ball.style.left = (fromRect.left + fromRect.width / 2 - 25) + 'px';
            ball.style.top = (fromRect.top + fromRect.height / 2 - 25) + 'px';
            ball.style.zIndex = '99999';
            ball.style.pointerEvents = 'none';
            ball.style.border = `4px solid ${selectedColor.glow}`;
            
            document.body.appendChild(ball);
            
            // Animate to target
            const startX = fromRect.left + fromRect.width / 2 - 25;
            const startY = fromRect.top + fromRect.height / 2 - 25;
            const endX = toRect.left + toRect.width / 2 - 25;
            const endY = toRect.top + toRect.height / 2 - 25;
            
            const duration = 1500;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                
                ball.style.left = currentX + 'px';
                ball.style.top = currentY + 'px';
                
                const scale = 1 + Math.sin(progress * Math.PI * 8) * 0.3;
                ball.style.transform = `scale(${scale})`;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    ball.style.transform = 'scale(2.5)';
                    ball.style.opacity = '0';
                    ball.style.transition = 'all 0.2s';
                    
                    setTimeout(() => {
                        ball.remove();
                        onComplete();
                    }, 200);
                }
            }
            
            animate();
        }

        function getReinforcementCount(player) {
            const territories = game.board.filter(c => c.owner === player).length;
            return Math.max(3, Math.floor(territories / 3));
        }

        function endTurn() {
            if (!game.gameMode || game.gameOver) return;
            if (game.phase === 'deploy' && game.armiesToDeploy > 0) return;
            
            // If in fortify phase, actually end turn
            if (game.phase === 'fortify') {
                game.currentPlayer = game.currentPlayer === 1 ? 2 : 1;
                game.turnCount++;
                game.phase = 'wizard_move';
                game.wizardMovesRemaining = 2;
                game.armiesToDeploy = getReinforcementCount(game.currentPlayer);
                game.selectedCell = null;
                
                updateUI();
                renderBoard();
                
                if (game.turnCount >= game.maxTurns * 2) {
                    checkWinCondition();
                    return;
                }
                
                if (game.gameMode === 'ai' && game.currentPlayer === 2) {
                    setTimeout(() => {
                        if (!game.gameOver) aiTurn();
                    }, 1000);
                }
            } else {
                // Move to next phase
                if (game.phase === 'wizard_move') {
                    game.phase = 'deploy';
                    game.wizardMovesRemaining = 0;
                } else if (game.phase === 'deploy') {
                    game.phase = 'expand';
                } else if (game.phase === 'expand') {
                    game.phase = 'attack';
                } else if (game.phase === 'attack') {
                    game.phase = 'fortify';
                }
                
                game.selectedCell = null;
                updateUI();
                renderBoard();
            }
        }

        function aiTurn() {
            showStatus('AI is thinking...');
            
            // Wizard movement phase
            aiWizardMove();
            
            setTimeout(() => {
                game.phase = 'deploy';
                updateUI();
                
                setTimeout(() => {
                    aiDeploy();
                    
                    setTimeout(() => {
                        game.phase = 'expand';
                        updateUI();
                        
                        setTimeout(() => {
                            aiExpand();
                            
                            setTimeout(() => {
                                game.phase = 'attack';
                                updateUI();
                                
                                setTimeout(() => {
                                    aiAttack();
                                    
                                    setTimeout(() => {
                                        game.phase = 'fortify';
                                        updateUI();
                                        
                                        setTimeout(() => {
                                            aiFortify();
                                            
                                            setTimeout(() => {
                                                if (!game.gameOver) {
                                                    endTurn();
                                                }
                                            }, 800);
                                        }, 800);
                                    }, 800);
                                }, 800);
                            }, 800);
                        }, 800);
                    }, 800);
                }, 800);
            }, 800);
        }

        function aiWizardMove() {
            // AI moves wizard toward enemies or defensively
            const wizardIndex = game.board.findIndex(c => c.owner === 2 && c.isWizard);
            if (wizardIndex === -1) return;
            
            for (let move = 0; move < 2; move++) {
                const currentWizard = game.board.findIndex(c => c.owner === 2 && c.isWizard);
                if (currentWizard === -1) break;
                
                const adjacentEmpty = getAdjacentCells(currentWizard).filter(adj => game.board[adj].owner === 0);
                
                if (adjacentEmpty.length > 0) {
                    // Move toward center or random direction
                    const target = adjacentEmpty[Math.floor(Math.random() * adjacentEmpty.length)];
                    
                    game.board[target].owner = 2;
                    game.board[target].armies = 1;
                    game.board[target].isWizard = true;
                    game.board[currentWizard].owner = 0;
                    game.board[currentWizard].armies = 0;
                    game.board[currentWizard].isWizard = false;
                    
                    renderBoard();
                    updateUI();
                }
            }
        }

        function aiDeploy() {
            const aiTerritories = game.board
                .map((c, i) => ({ i, c }))
                .filter(x => x.c.owner === 2);
            
            while (game.armiesToDeploy > 0) {
                // Prefer expanding to adjacent empty squares, especially bonus ones
                const expandOptions = [];
                aiTerritories.forEach(t => {
                    const adjacentEmpty = getAdjacentCells(t.i).filter(adj => game.board[adj].owner === 0);
                    adjacentEmpty.forEach(adj => {
                        if (!expandOptions.includes(adj)) {
                            expandOptions.push(adj);
                        }
                    });
                });
                
                // Check for bonus squares
                const bonusExpand = expandOptions.filter(i => game.board[i].isBonus);
                
                if (bonusExpand.length > 0 && Math.random() > 0.3) {
                    // Deploy to bonus square
                    const target = bonusExpand[0];
                    const bonusArmies = game.board[target].isBonus ? game.board[target].armies : 0;
                    game.board[target].owner = 2;
                    game.board[target].armies = 1 + bonusArmies;
                    game.board[target].isBonus = false;
                    game.armiesToDeploy--;
                } else if (expandOptions.length > 0 && Math.random() > 0.4) {
                    // Deploy to adjacent empty
                    const target = expandOptions[Math.floor(Math.random() * expandOptions.length)];
                    const bonusArmies = game.board[target].isBonus ? game.board[target].armies : 0;
                    game.board[target].owner = 2;
                    game.board[target].armies = 1 + bonusArmies;
                    game.board[target].isBonus = false;
                    game.armiesToDeploy--;
                } else {
                    // Deploy to existing territory
                    const borderTerritories = aiTerritories.filter(t => {
                        const adjacentEnemies = getAdjacentCells(t.i).filter(adj => game.board[adj].owner === 1);
                        return adjacentEnemies.length > 0;
                    });
                    
                    const target = borderTerritories.length > 0
                        ? borderTerritories[Math.floor(Math.random() * borderTerritories.length)]
                        : aiTerritories[Math.floor(Math.random() * aiTerritories.length)];
                    
                    game.board[target.i].armies++;
                    game.armiesToDeploy--;
                }
            }
            
            renderBoard();
            updateUI();
        }

        function aiExpand() {
            const aiTerritories = game.board
                .map((c, i) => ({ i, c }))
                .filter(x => x.c.owner === 2 && x.c.armies > 1);
            
            for (let territory of aiTerritories) {
                const adjacentEmpty = getAdjacentCells(territory.i)
                    .filter(adj => game.board[adj].owner === 0)
                    .map(adj => ({ i: adj, isBonus: game.board[adj].isBonus }));
                
                if (adjacentEmpty.length > 0) {
                    // Prioritize bonus squares
                    const bonusSquares = adjacentEmpty.filter(e => e.isBonus);
                    const target = bonusSquares.length > 0 ? bonusSquares[0] : adjacentEmpty[0];
                    
                    const armiesToMove = Math.floor(game.board[territory.i].armies / 2);
                    if (armiesToMove >= 1) {
                        performExpansion(territory.i, target.i, armiesToMove);
                        renderBoard();
                        updateUI();
                        break;
                    }
                }
            }
        }

        function aiAttack() {
            const aiTerritories = game.board
                .map((c, i) => ({ i, c }))
                .filter(x => x.c.owner === 2 && x.c.armies > 1);
            
            let attacksMade = 0;
            const maxAttacks = 3;
            
            for (let territory of aiTerritories) {
                if (attacksMade >= maxAttacks) break;
                
                const adjacentEnemies = getAdjacentCells(territory.i)
                    .filter(adj => game.board[adj].owner === 1)
                    .map(adj => ({ i: adj, armies: game.board[adj].armies }));
                
                // Attack if we have more armies (will win)
                const winnable = adjacentEnemies.filter(e => 
                    game.board[territory.i].armies > e.armies
                );
                
                if (winnable.length > 0) {
                    const target = winnable.sort((a, b) => a.armies - b.armies)[0];
                    performAttack(territory.i, target.i);
                    attacksMade++;
                    renderBoard();
                    updateUI();
                    
                    if (!game.gameOver) {
                        checkWinCondition();
                    }
                    if (game.gameOver) break;
                }
            }
        }

        function aiFortify() {
            // AI fortifies by moving armies from interior to border territories
            const aiTerritories = game.board
                .map((c, i) => ({ i, c }))
                .filter(x => x.c.owner === 2 && x.c.armies > 2);
            
            for (let territory of aiTerritories) {
                const adjacentCells = getAdjacentCells(territory.i);
                const hasEnemyNeighbor = adjacentCells.some(adj => game.board[adj].owner === 1);
                
                // If this territory has no enemies nearby, it's interior
                if (!hasEnemyNeighbor) {
                    // Find adjacent friendly territories that DO have enemies
                    const borderFriendlies = adjacentCells.filter(adj => {
                        if (game.board[adj].owner !== 2) return false;
                        const adjNeighbors = getAdjacentCells(adj);
                        return adjNeighbors.some(n => game.board[n].owner === 1);
                    });
                    
                    if (borderFriendlies.length > 0) {
                        // Move half the armies to the border
                        const target = borderFriendlies[0];
                        const armiesToMove = Math.floor(game.board[territory.i].armies / 2);
                        if (armiesToMove >= 1) {
                            performFortify(territory.i, target, armiesToMove);
                            renderBoard();
                            updateUI();
                            break; // Only fortify once per turn
                        }
                    }
                }
            }
        }

        function getAdjacentCells(i) {
            const adjacent = [];
            const row = Math.floor(i / 6);
            const col = i % 6;
            
            if (row > 0) adjacent.push(i - 6);
            if (row < 5) adjacent.push(i + 6);
            if (col > 0) adjacent.push(i - 1);
            if (col < 5) adjacent.push(i + 1);
            
            return adjacent;
        }

        function checkWinCondition() {
            const p1Territories = game.board.filter(c => c.owner === 1).length;
            const p2Territories = game.board.filter(c => c.owner === 2).length;
            const p1Armies = game.board.filter(c => c.owner === 1).reduce((sum, c) => sum + c.armies, 0);
            const p2Armies = game.board.filter(c => c.owner === 2).reduce((sum, c) => sum + c.armies, 0);
            
            // Check if either player has no armies left
            if (p1Armies === 0 || p1Territories === 0) {
                showStatus('üéâ Player 2 WINS - Player 1 eliminated! üéâ');
                game.gameOver = true;
            } else if (p2Armies === 0 || p2Territories === 0) {
                showStatus('üéâ Player 1 WINS - Player 2 eliminated! üéâ');
                game.gameOver = true;
            } else if (game.turnCount >= game.maxTurns * 2) {
                // Turn limit reached - count territories
                if (p1Territories > p2Territories) {
                    showStatus(`üéâ Player 1 WINS with ${p1Territories} territories! üéâ`);
                } else if (p2Territories > p1Territories) {
                    showStatus(`üéâ Player 2 WINS with ${p2Territories} territories! üéâ`);
                } else {
                    showStatus('ü§ù DRAW! Both players control equal territories! ü§ù');
                }
                game.gameOver = true;
            }
            
            updateUI();
        }

        function updateUI() {
            const p1Territories = game.board.filter(c => c.owner === 1).length;
            const p2Territories = game.board.filter(c => c.owner === 2).length;
            const p1Armies = game.board.filter(c => c.owner === 1).reduce((sum, c) => sum + c.armies, 0);
            const p2Armies = game.board.filter(c => c.owner === 2).reduce((sum, c) => sum + c.armies, 0);
            
            document.getElementById('p1-territories').textContent = p1Territories;
            document.getElementById('p2-territories').textContent = p2Territories;
            document.getElementById('p1-armies').textContent = p1Armies;
            document.getElementById('p2-armies').textContent = p2Armies;
            
            document.getElementById('p1-card').classList.toggle('active', game.currentPlayer === 1 && !game.gameOver);
            document.getElementById('p2-card').classList.toggle('active', game.currentPlayer === 2 && !game.gameOver);
            
            const endBtn = document.getElementById('end-btn');
            endBtn.disabled = !game.gameMode || game.gameOver || (game.phase === 'deploy' && game.armiesToDeploy > 0);
            
            // Update button text based on phase
            if (game.phase === 'fortify') {
                endBtn.textContent = 'End Turn';
            } else {
                endBtn.textContent = 'Next Phase';
            }
            
            if (!game.gameOver && game.gameMode) {
                if (game.phase === 'wizard_move') {
                    showStatus(`Player ${game.currentPlayer}: Move your wizard (${game.wizardMovesRemaining} moves remaining)`);
                    document.getElementById('phase-indicator').textContent = 'üîÆ WIZARD MOVEMENT';
                    document.getElementById('phase-indicator').style.background = '#fef3c7';
                    document.getElementById('phase-indicator').style.color = '#92400e';
                } else if (game.phase === 'deploy') {
                    showStatus(`Player ${game.currentPlayer}: Deploy ${game.armiesToDeploy} armies to your territories or adjacent empty squares`);
                    document.getElementById('phase-indicator').textContent = 'Current Phase: 1Ô∏è‚É£ DEPLOY';
                    document.getElementById('phase-indicator').style.background = '#dbeafe';
                    document.getElementById('phase-indicator').style.color = '#1e40af';
                } else if (game.phase === 'expand') {
                    showStatus(`Player ${game.currentPlayer}: Expand to adjacent empty squares (optional - click Next Phase to skip)`);
                    document.getElementById('phase-indicator').textContent = 'Current Phase: 2Ô∏è‚É£ EXPAND';
                    document.getElementById('phase-indicator').style.background = '#d1fae5';
                    document.getElementById('phase-indicator').style.color = '#065f46';
                } else if (game.phase === 'attack') {
                    showStatus(`Player ${game.currentPlayer}: Attack adjacent enemies (optional - click Next Phase to skip)`);
                    document.getElementById('phase-indicator').textContent = 'Current Phase: 3Ô∏è‚É£ ATTACK';
                    document.getElementById('phase-indicator').style.background = '#fee2e2';
                    document.getElementById('phase-indicator').style.color = '#991b1b';
                } else if (game.phase === 'fortify') {
                    showStatus(`Player ${game.currentPlayer}: Move armies between your territories (optional - click End Turn to finish)`);
                    document.getElementById('phase-indicator').textContent = 'Current Phase: 4Ô∏è‚É£ FORTIFY';
                    document.getElementById('phase-indicator').style.background = '#e9d5ff';
                    document.getElementById('phase-indicator').style.color = '#6b21a8';
                }
            }
        }

        function showStatus(msg) {
            document.getElementById('status').textContent = msg;
        }

        init();
    </script>
</body>
  </html>
